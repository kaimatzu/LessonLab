// import 'package:lessonlab/messages/entry/upload/uploaded_content.pb.dart'

// import 'package:lessonlab/messages/entry/menu/menu.pb.dart';
import 'package:lessonlab/src/global_models/lesson_model.dart';
import 'package:lessonlab/src/global_models/quiz_model.dart';
import 'package:lessonlab/src/lessonlab_modules/entry/menu/menu_model.dart';

import 'dart:developer' as developer;

import 'package:lessonlab/messages/entry/menu/menu.pb.dart'
    // ignore: library_prefixes
    as RinfInterface;
import 'package:rinf/rinf.dart';

class MenuConnectionOrchestrator {
  void sendData() async {}

  Future<MenuModel> getData() async {
    final menuModel = getMenuModel();

    // menuModel.lessons = getLessons();
    // menuModel.quizzes = Future.value([]);
    // menuModel.lessons.add();
    // final menuModel = getMenuModel();

    return menuModel;
  }

  /// Retrieves data from the menu object handler in Rust
  ///
  /// @see menu_connection_orchestrator.dart
  /// @see MenuConnectionOrchestrator
  Future<MenuModel> getMenuModel() async {
    final requestMessage = RinfInterface.ReadRequest(req: true);
    final rustRequest = RustRequest(
      resource: RinfInterface.ID,
      operation: RustOperation.Read,
      message: requestMessage.writeToBuffer(),
      // blob: NO BLOB
    );
    final rustResponse = await requestToRust(rustRequest);
    final responseMessage = RinfInterface.ReadResponse.fromBuffer(
      // TODO: fix this null error
      rustResponse.message!,
    );

    var content = responseMessage.menuModel;
    // get autogenerated content.lessons and convert it into List<LessonModel>

    // Initialize LessonModel using DTO from Proto using the `fromAutogenerated` constructor
    final List<LessonModel> lessonModels = content.lessons
        .map((autogeneratedLesson) =>
            LessonModel.fromAutogenerated(autogeneratedLesson))
        .toList();

    final menuModel = MenuModel();
    menuModel.lessons = Future.value(lessonModels);
    menuModel.quizzes = Future.value([]);

    lessonModels[0].id.then((value) => developer.log(value.toString()));

    // data are retrieved from menu_data_handlers.rs

    return menuModel;
  }

  // void sendMenuModel(MenuModel menuModel) async {
  //   final requestMessage = RinfInterface.CreateRequest(req: true);
  //
  //   // view menu.proto
  // }

  Future<int> deleteLesson(int id) async {
    final requestMessage = RinfInterface.DeleteRequest(id: id, isLesson: true);
    final rustRequest = RustRequest(
      resource: RinfInterface.ID,
      operation: RustOperation.Delete,
      message: requestMessage.writeToBuffer(),
    );
    final rustResponse = await requestToRust(rustRequest);
    final responseMessage = RinfInterface.DeleteResponse.fromBuffer(
      rustResponse.message!,
    );
    developer.log('${responseMessage.statusCode}', name: 'delete lesson');
    return responseMessage.statusCode;
  }

  Future<int> deleteQuiz(int id) async {
    final requestMessage = RinfInterface.DeleteRequest(id: id, isLesson: false);
    final rustRequest = RustRequest(
      resource: RinfInterface.ID,
      operation: RustOperation.Delete,
      message: requestMessage.writeToBuffer(),
    );
    final rustResponse = await requestToRust(rustRequest);
    final responseMessage = RinfInterface.DeleteResponse.fromBuffer(
      rustResponse.message!,
    );
    developer.log('${responseMessage.statusCode}', name: 'delete quiz');
    return responseMessage.statusCode;
  }

  Future<int> updateLesson(LessonModel lesson) async {
    String title = '';
    String content = '';
    String location = '';

    lesson.title.then((value) => title = value);
    lesson.content.then((value) => content = value);
    lesson.location.then((value) => location = value);

    final pbLesson = RinfInterface.LessonModel(
      title: title,
      content: content,
      location: location,
    );
    lesson.title.then((value) => pbLesson.title = value);
    final requestMessage =
        RinfInterface.UpdateRequest(lesson: pbLesson, isLesson: true);
    final rustRequest = RustRequest(
      resource: RinfInterface.ID,
      operation: RustOperation.Update,
      message: requestMessage.writeToBuffer(),
    );
    final rustResponse = await requestToRust(rustRequest);
    final responseMessage = RinfInterface.UpdateResponse.fromBuffer(
      rustResponse.message!,
    );
    developer.log('${responseMessage.statusCode}', name: 'update lesson');
    return responseMessage.statusCode;
  }

  Future<int> updateQuiz(QuizModel quiz) async {
    final requestMessage = RinfInterface.UpdateRequest(isLesson: false);
    final rustRequest = RustRequest(
      resource: RinfInterface.ID,
      operation: RustOperation.Update,
      message: requestMessage.writeToBuffer(),
    );
    final rustResponse = await requestToRust(rustRequest);
    final responseMessage = RinfInterface.UpdateResponse.fromBuffer(
      rustResponse.message!,
    );
    developer.log('${responseMessage.statusCode}', name: 'update quiz');
    return responseMessage.statusCode;
  }

  /*
    PROTO
    messages/entry/menu/menu.proto

    RUST
    menu_data_handlers.rs

    HTTP METHODS

    GET           -> get data
    POST          -> send data
    PUT           -> update data (complete)
    PATCH         -> update data (partial)
    DELETE        -> delete data
    TRACE         -> diagnostics, debuggin
    HEAD          -> get metadata
    OPTONS        -> get supported methods
    CONNECT       -> connect server-side
    PRI           -> ?

    source:
    https://www.theserverside.com/blog/Coffee-Talk-Java-News-Stories-and-Opinions/HTTP-methods
  */
}
